from __future__ import annotations

import json
import os
import logging
from typing import List, Optional
from pydantic import BaseModel, Field
from openai import AsyncOpenAI
from agents import Agent, WebSearchTool, function_tool, OpenAIChatCompletionsModel, handoff, GuardrailFunctionOutput, RunContextWrapper, output_guardrail
from dotenv import load_dotenv

from .swizzy_tools import (
    read_file_content,
    create_document,
    extract_text_from_image,
    ponder_document_request,
    create_markdown,
    edit_markdown_section,
    convert_file_format,
    analyze_content_structure,
)
from .tools import (
    analyze_spreadsheet,
    create_spreadsheet,
    modify_spreadsheet,
    ponder_spreadsheet_request
)
from .tools.content_tools import (
    convert_pdf_to_markdown,
    convert_to_markdown,
    read_markdown,
    create_markdown,
    edit_markdown_section,
    convert_file_format,
    analyze_content_structure,
)
from .tools.web_tools import (
    read_url,
    extract_url_to_markdown,
    search_web,
    search_with_budget,
    reset_search_budget,
    get_search_cost_summary
)
from .tools.research_tools import (
    plan_research,
    execute_research_plan,
    research_topic
)
from .tools.data_extraction_tools import (
    extract_structured_data,
    convert_json_to_excel,
    extract_invoice_to_excel,
    extract_table_from_document
)
from .tools.memory_tools import (
    store_memory,
    retrieve_memory,
    update_memory,
    delete_memory,
    search_memories,
    store_link,
    get_links_by_tag
)

logger = logging.getLogger(__name__)

# Load environment variables if not already loaded
load_dotenv()

# Verify environment variables and setup OpenAI client for Gemini
api_key = os.getenv("GOOGLE_API_KEY") # Assuming Gemini uses GOOGLE_API_KEY based on prior context
base_url = os.getenv("OPENAI_BASE_URL") # Assuming a proxy/custom base URL

if not api_key or not base_url:
    raise ValueError("Missing required environment variables: GOOGLE_API_KEY and OPENAI_BASE_URL must be set")

# Create custom OpenAI client
client = AsyncOpenAI(
    api_key=api_key,
    base_url=base_url
)

# Create the model configuration for Gemini
gemini_model = OpenAIChatCompletionsModel(
    model="gemini-2.0-flash", # Or use gemini-1.5-flash, or the appropriate model name
    openai_client=client,
)

# Instruction Snippets
STYLE_INSTRUCTIONS = "Format your response clearly using markdown."

# --- Define Output Model --- 
class SwizzyOutput(BaseModel):
    reasoning: str = Field(description="Brief reasoning for the chosen action (tool use or handoff).")
    action_taken: str = Field(description="Description of the action performed (e.g., 'Used read_file_content', 'Handed off to spreadsheet_agent', 'Executed analysis script').")
    outcome: str = Field(description="Summary of the outcome (e.g., 'Success', 'Completed analysis', 'Error occurred', 'Handoff initiated').")
    response_to_user: str = Field(description="The final message to convey to the user.")
    generated_handles: Optional[List[str]] = Field(default=None, description="List of new file handles generated by a specialist agent, if any.")
    error_details: Optional[str] = Field(default=None, description="Details of any error encountered during tool use or handoff, if applicable.")


# --- Define Output Guardrails FIRST --- 

@output_guardrail
async def swizzy_consistency_guardrail(
    context: RunContextWrapper, agent: Agent, output: SwizzyOutput | str # Accept str too
) -> GuardrailFunctionOutput:
    """Checks consistency between Swizzy's reported action, outcome, and response."""

    parsed_output: SwizzyOutput | None = None
    inconsistencies = []
    output_info = {"consistency_checks_run": True, "inconsistencies_found": []}

    if isinstance(output, str):
        logger.info("Swizzy Consistency Guardrail received string output, attempting to parse JSON.")
        json_str = json_str[7:]
            if json_str.endswith("```"):
                json_str = json_str[:-3]
            json_str = json_str.strip()
            
            # Handle potential Gemini quirk of non-JSON string before/after JSON block
            try:
                start_index = json_str.index('{')
                end_index = json_str.rindex('}') + 1
                json_str = json_str[start_index:end_index]
            except ValueError:
                # If '{' or '}' not found, proceed assuming it might be valid JSON already
                pass

            parsed_output = SwizzyOutput.model_validate_json(json_str)
            logger.info("Successfully parsed JSON string from output.")
        except Exception as e:
            parsing_error = f"Failed to parse JSON from string output: {e}\nRaw string: {output}"
            logger.error(parsing_error)
            inconsistencies.append("Output was an unparsable string.")
            tripwire = True # Failed to parse structured output
    elif isinstance(output, SwizzyOutput):
        logger.info("Swizzy Consistency Guardrail received SwizzyOutput object.")
        parsed_output = output
    else:
        parsing_error = f"Guardrail received unexpected output type: {type(output)}"
        logger.error(parsing_error)
        inconsistencies.append("Guardrail received unexpected output type.")
        tripwire = True

    # Proceed with checks only if parsing was successful
    if parsed_output:
        action = parsed_output.action_taken.lower()
        # Handle potential None outcome if parsing from string
        outcome_val = getattr(parsed_output, 'outcome', None)
        outcome = str(outcome_val).lower() if outcome_val is not None else ""
        response = parsed_output.response_to_user.lower()
        handles = parsed_output.generated_handles
        error = parsed_output.error_details

        # Check 1: Error reporting consistency
        if "error" in outcome and not error:
            inconsistencies.append("Outcome mentions error, but no error_details provided.")
        if error and "error" not in outcome:
            inconsistencies.append("Error details provided, but outcome doesn't mention error.")
            # tripwire = False # Might allow this, but log it

        # Check 2: File handle consistency
        file_creation_handoff = "spreadsheet_agent" in action or "document_agent" in action
        if file_creation_handoff and "success" in outcome and not handles:
            pass 
        if handles and not file_creation_handoff:
            inconsistencies.append("Generated handles provided, but action wasn't a file creation handoff.")
            tripwire = True

        # Check 3: Response mentions error if outcome is error
        if "error" in outcome and "error" not in response and "fail" not in response:
            inconsistencies.append("Outcome is error, but response_to_user doesn't clearly state an error.")
            # tripwire = True 

        # Check 4: Response mentions handles if provided
        if handles and all(handle not in response for handle in handles):
            inconsistencies.append("Generated handles provided, but not mentioned in response_to_user.")
            # tripwire = True

    # Log results
    if inconsistencies:
        logger.warning(f"Swizzy Consistency Guardrail Check: Inconsistencies found: {inconsistencies}, Tripwire={tripwire}")
    elif parsing_error:
        logger.warning(f"Swizzy Consistency Guardrail Check: Parsing failed, Tripwire={tripwire}") # Already logged error
    else:
        logger.info("Swizzy Consistency Guardrail Check: Passed.")

    return GuardrailFunctionOutput(
        output_info={"consistency_checks_run": True, "inconsistencies_found": inconsistencies, "parsing_error": parsing_error},
        tripwire_triggered=tripwire,
    )

@output_guardrail
async def specialist_file_creation_guardrail(
    context: RunContextWrapper, agent: Agent, output: SwizzyOutput
) -> GuardrailFunctionOutput:
    """Checks if file creation agents correctly report handles on success."""
    # Ensure output is the correct type first
    if not isinstance(output, SwizzyOutput):
        logger.error(f"Specialist Guardrail Check ({agent.name}): Received unexpected output type {type(output)}")
        return GuardrailFunctionOutput(
            output_info={"specialist_checks_run": False, "inconsistencies_found": ["Invalid output type received"]},
            tripwire_triggered=True
        )

    outcome = output.outcome.lower() if output.outcome else ""
    handles = output.generated_handles
    error = output.error_details

    inconsistencies = []
    tripwire = False

    # Check 1: Success implies handles
    if "success" in outcome and not handles:
        inconsistencies.append(f"Agent {agent.name} reported success but provided no generated_handles.")
        tripwire = True # Success without a handle is unexpected for these agents

    # Check 2: Error implies details (or outcome explicitly mentions error)
    if "error" in outcome and not error:
        inconsistencies.append(f"Agent {agent.name} reported error outcome but provided no error_details.")
        # tripwire = False # Might allow this, but log it

    # Check 3: Details imply error outcome
    if error and "error" not in outcome:
        inconsistencies.append(f"Agent {agent.name} provided error_details but did not report 'Error occurred' in outcome.")
        # tripwire = True # Ensure outcome reflects the error

    if inconsistencies:
        logger.warning(f"Specialist Guardrail Check ({agent.name}): Inconsistencies found: {inconsistencies}, Tripwire={tripwire}")
    else:
        logger.info(f"Specialist Guardrail Check ({agent.name}): Passed.")

    return GuardrailFunctionOutput(
        output_info={"specialist_checks_run": True, "inconsistencies_found": inconsistencies},
        tripwire_triggered=tripwire,
    )

# Memory Agent Configuration
memory_agent_config = Agent(
    name="Memory Agent",
    instructions=(
        "You are a Memory Management Agent. "
        "Your primary responsibility is to manage memories effectively. "
        "You can store, retrieve, update, delete, and search memories. "
        "Use the provided tools to interact with the memory system. "
        "Follow these instructions:"
        "- When asked to store something, use the store_memory tool. "
        "- When asked to retrieve something, use the retrieve_memory tool. "
        "- When asked to update something, use the update_memory tool. "
        "- When asked to delete something, use the delete_memory tool. "
        "- When asked to search something, use the search_memories tool. "
        "- When asked to store a link, use the store_link tool. "
        "- When asked to get links by tag, use the get_links_by_tag tool."
        "- Always use appropriate tags to categorize your memories for easy retrieval."
        "- Prioritize accuracy and relevance when managing memories."
        f"{STYLE_INSTRUCTIONS}"
    ),
    model=gemini_model,
    tools=[
        store_memory,
        retrieve_memory,
        update_memory,
        delete_memory,
        search_memories,
        store_link,
        get_links_by_tag
    ],
)

# List of tools that are not memory tools or agents
memory_tools_list = [
    # Spreadsheet tools
    ponder_spreadsheet_request,
    create_spreadsheet,
    modify_spreadsheet,
    read_file_content,
    analyze_spreadsheet,
    # Document tools
    ponder_document_request,
    create_document,
    extract_text_from_image,
    read_markdown,
    create_markdown,
    edit_markdown_section,
    convert_file_format,
    analyze_content_structure,
    convert_pdf_to_markdown,
    convert_to_markdown,
    # Other tools
    plan_research,
    execute_research_plan,
    research_topic,
    search_web,
    search_with_budget,
    reset_search_budget,
    get_search_cost_summary,
]

# --- Define Specialist Agents --- 

# Agent for Spreadsheets (Create/Modify)
spreadsheet_agent = Agent(
    name="Spreadsheet Specialist",
    instructions=(
        "You are a specialist in dealing with spreadsheets (.xlsx, .csv). Your primary responsibility is to produce high-quality spreadsheet files that meet client requirements. "
        "**CRITICAL: ALWAYS THINK BEFORE YOU ACT!** You must use the ponder_spreadsheet_request tool FIRST before taking any action. "
        "Your workflow must ALWAYS follow this sequence: "
        "1. PONDER: Use ponder_spreadsheet_request to think through the request and determine the best approach "
        "2. ACT: Based on the pondering results, use the appropriate spreadsheet tools "
        "3. RESPOND: Provide a comprehensive response to the client "
        "You have these tools at your disposal: "
        "- ponder_spreadsheet_request: MUST be called FIRST to think through the request "
        "- read_file_content: Use this to read existing spreadsheet files "
        "- create_spreadsheet: Use this to create new spreadsheets with advanced formatting "
        "- modify_spreadsheet: Use this to modify existing spreadsheets "
        "- analyze_spreadsheet: Use this to perform complex analysis operations on spreadsheets "
        "**CRITICAL RULES**: "
        "1. NEVER skip the pondering step - ALWAYS call ponder_spreadsheet_request first "
        "2. NEVER claim to have read, created, or modified a file without ACTUALLY CALLING THE CORRESPONDING TOOL "
        "3. NEVER make up fake data or pretend to analyze a file you haven't read with the tool "
        "4. NEVER tell clients to wait - either complete the task with your tools or report an error "
        "5. NEVER promise future actions - you must complete all requested tasks immediately "
        "6. ALWAYS check for a file handle in system notes like '[System Note: Please operate on the file with handle: 'filename.xlsx']' "
        "7. ALWAYS include the file handle in your tool calls - this is REQUIRED for the tools to work "
        "8. ALWAYS return a file back to the requester so your output can be validated "
        "9. If you weren't provided a file, flag this in your response "
        "**ADVANCED SPREADSHEET CREATION**: "
        "The create_spreadsheet tool now supports advanced Excel features including formulas, formatting, and styles. "
        "You must provide data in JSON format with the following structure: "
        "```json\n"
        "{\n"
        "  \"sheets\": [\n"
        "    {\n"
        "      \"name\": \"Sheet1\",\n"
        "      \"data\": [\n"
        "        [\"Header1\", \"Header2\", \"Header3\"],\n"
        "        [\"Value1\", 10, \"=B2*2\"],\n"
        "        [\"Value2\", 20, \"=B3*2\"]\n"
        "      ],\n"
        "      \"column_widths\": {\"A\": 15, \"B\": 10},\n"
        "      \"formats\": [\n"
        "        {\"range\": \"A1:C1\", \"bold\": true, \"bg_color\": \"FFCCCCCC\"},\n"
        "        {\"range\": \"B2:B3\", \"number_format\": \"#,##0.00\"}\n"
        "      ]\n"
        "    }\n"
        "  ]\n"
        "}\n"
        "```\n"
        "Key features you can use:\n"
        "- Excel formulas (start with =): SUM, AVERAGE, IF, VLOOKUP, etc.\n"
        "- Cell formatting: bold, background colors (using 'FFRRGGBB' format), number formats\n"
        "- Multiple sheets with different data and formatting\n"
        "- Column width adjustments\n"
        "**IMPORTANT**: For background colors, use 8-character hex values with 'FF' prefix (e.g., 'FFCCCCCC' for light gray)\n"
        "**ADVANCED SPREADSHEET ANALYSIS**: "
        "The analyze_spreadsheet tool allows you to perform complex operations and analysis on spreadsheets. "
        "You must provide an analysis configuration in JSON format with the following structure: "
        "```json\n"
        "{\n"
        "  \"operations\": [\n"
        "    {\n"
        "      \"type\": \"summary_stats\",\n"
        "      \"target\": \"B2:B10\",\n"
        "      \"sheet\": \"Sheet1\",\n"
        "      \"metrics\": [\"mean\", \"median\", \"sum\", \"min\", \"max\", \"count\"]\n"
        "    },\n"
        "    {\n"
        "      \"type\": \"filter\",\n"
        "      \"target\": \"A1:D20\",\n"
        "      \"sheet\": \"Sheet1\",\n"
        "      \"condition\": {\n"
        "        \"column\": \"B\",\n"
        "        \"operator\": \">\",\n"
        "        \"value\": 100\n"
        "      }\n"
        "    },\n"
        "    {\n"
        "      \"type\": \"extract\",\n"
        "      \"target\": \"A1:D20\",\n"
        "      \"sheet\": \"Sheet1\",\n"
        "      \"format\": \"json\"\n"
        "    },\n"
        "    {\n"
        "      \"type\": \"correlation\",\n"
        "      \"columns\": [\"B\", \"C\"],\n"
        "      \"sheet\": \"Sheet1\",\n"
        "      \"range\": \"A1:D20\"\n"
        "    }\n"
        "  ]\n"
        "}\n"
        "```\n"
        "Available analysis operations:\n"
        "1. **summary_stats**: Calculate statistics (mean, median, sum, min, max, count) for a range of cells\n"
        "2. **filter**: Filter data based on conditions (>, >=, <, <=, ==, !=, contains)\n"
        "3. **extract**: Extract data from a range and convert to structured format\n"
        "4. **formula_result**: Calculate the result of a custom Excel formula\n"
        "5. **correlation**: Calculate correlation between two columns\n"
        "6. **trend_analysis**: Perform linear regression and predict future values\n"
        "7. **pivot**: Create pivot tables with custom aggregations (sum, avg, min, max, count)\n"
        "**EXAMPLES OF PROPER TOOL USAGE**: "
        "- To ponder: `ponder_spreadsheet_request(request_description='Create a budget spreadsheet', points_to_consider='Need to determine columns, format, and initial data')` "
        "- To read a file: `read_file_content(file_handle='sales_data.xlsx')` "
        "- To create a formatted spreadsheet: `create_spreadsheet(filename='budget.xlsx', spreadsheet_data='{\"sheets\":[{\"name\":\"Budget\",\"data\":[[\"Category\",\"January\",\"February\",\"March\",\"Total\"],[\"Income\",1000,1200,1300,\"=SUM(B2:D2)\"],[\"Expenses\",800,850,900,\"=SUM(B3:D3)\"],[\"Savings\",\"=B2-B3\",\"=C2-C3\",\"=D2-D3\",\"=E2-E3\"]],\"column_widths\":{\"A\":15,\"B\":10,\"C\":10,\"D\":10,\"E\":10},\"formats\":[{\"range\":\"A1:E1\",\"bold\":true,\"bg_color\":\"FFCCCCCC\"},{\"range\":\"B2:E4\",\"number_format\":\"$#,##0.00\"}]}')` "
        "- To modify a spreadsheet: `modify_spreadsheet(file_handle='inventory.xlsx', operations='[{\"operation\": \"update_cell\", \"cell\": \"B5\", \"value\": \"42\"}]')` "
        "- To analyze a spreadsheet: `analyze_spreadsheet(file_handle='sales_data.xlsx', analysis_config='{\"operations\":[{\"type\":\"summary_stats\",\"target\":\"B2:B10\",\"sheet\":\"Sheet1\",\"metrics\":[\"mean\",\"sum\",\"max\"]},{\"type\":\"correlation\",\"columns\":[\"B\",\"C\"],\"sheet\":\"Sheet1\",\"range\":\"A1:D20\"}]}')` "
        "For each request type: "
        "- PONDER: Call ponder_spreadsheet_request with a description of the request and points to consider "
        "- READ: Use read_file_content with the file handle "
        "- CREATE: Use create_spreadsheet with the necessary data, formulas, and formatting "
        "- MODIFY: Use modify_spreadsheet to manipulate the spreadsheet and make intelligent edits to it "
        "- ANALYZE: Use analyze_spreadsheet to perform complex operations and extract insights from the data "
        "Your output MUST include: "
        "- For file CREATION: The new file handle in 'generated_handles' "
        "- For file MODIFICATION: Description of changes made to the existing file "
        "- For file ANALYSIS: Clear insights from the data "
        "**CRITICAL**: You MUST structure your response using the 'SwizzyOutput' format as a proper JSON object. "
        "Example of CORRECT format:\n"
        "{\n"
        "  \"reasoning\": \"After pondering the request, I determined that the client needed a sales analysis spreadsheet.\",\n"
        "  \"action_taken\": \"First used ponder_spreadsheet_request to analyze the approach, then read_file_content to read the existing data, and finally created a summary spreadsheet.\",\n"
        "  \"outcome\": \"Success\",\n"
        "  \"response_to_user\": \"Your sales data shows a 15% increase in Q2 compared to Q1. The top-performing product was Widget X with 45% of total revenue.\",\n"
        "  \"generated_handles\": [\"analysis_report.xlsx\"],\n"
        "  \"error_details\": null\n"
        "}\n"
        "Your 'response_to_user' should be comprehensive and professional, addressing all aspects of the client's request. "
        f" {STYLE_INSTRUCTIONS}"
        "**IMPORTANT: LOGGING ACTIONS AND DECISIONS**"
        "- ALWAYS log your significant actions and decisions using the store_memory tool"
        "- Include links to relevant resources using the store_link tool"
    ),
    model=gemini_model,  # Or preferred model
    tools=[
        store_memory,
        retrieve_memory,
        update_memory,
        delete_memory,
        search_memories,
        store_link,
        get_links_by_tag
    ],
)

memory_agent = Agent(
    **memory_agent_config.model_dump(), tools=[*memory_agent_config.tools, *memory_tools_list]
)

# Agent for Documents (Create)
document_agent = Agent(
    name="Document Specialist",
    instructions=(
        "You are a specialist in dealing with Markdown documents (.md) as your primary format, with support for other formats (.docx, .pdf, .txt). "
        "Your primary responsibility is to produce high-quality Markdown documents that meet client requirements. "
        "**MARKDOWN IS YOUR CENTRAL LANGUAGE** - you should always prefer working with Markdown files for maximum flexibility and editability. "
        "When given other formats, you should convert them to Markdown for editing, and only convert back to other formats when specifically requested. "
        
        "**CRITICAL RULES**: "
        "1. NEVER skip the pondering step - ALWAYS call ponder_document_request first "
        "2. NEVER claim to have read, created, or modified a file without ACTUALLY CALLING THE CORRESPONDING TOOL "
        "3. NEVER make up fake data or pretend to analyze a file you haven't read with the tool "
        "4. NEVER tell clients to wait - either complete the task with your tools or report an error "
        
        "**DOCUMENT CAPABILITIES**: "
        "- READ: You can read Markdown (.md) and text (.txt) files directly "
        "- CREATE: You can create Markdown (.md) and text (.txt) files with rich formatting "
        "- EDIT: You can perform targeted edits on Markdown files without rewriting the entire document "
        "- CONVERT: You can convert between formats (PDF→Markdown, DOCX→Markdown, Markdown→DOCX) while preserving formatting "
        "- ANALYZE: You can analyze document structure to understand headings and sections "
        "- EXTRACT: You can extract text from images using OCR "
        
        "**WORKING WITH NON-MARKDOWN FORMATS**: "
        "When given PDF or DOCX files, ALWAYS convert them to Markdown first using convert_to_markdown, "
        "then perform your operations on the Markdown file, and only convert back to the original format if requested. "
        "This workflow ensures maximum flexibility and editability. "
        
        "**MARKDOWN FEATURES YOU SUPPORT**: "
        "- Headings (# to ######) "
        "- Formatting (bold, italic, underline, strikethrough) "
        "- Links [text](url) "
        "- Images ![alt text](image_url) "
        "- Lists (ordered and unordered) "
        "- Tables with proper formatting "
        "- Code blocks with syntax highlighting "
        "- Blockquotes "
        "- Horizontal rules "
        "- YAML frontmatter for document metadata "
        
        "For each request type: "
        "- READ: Use read_markdown with the file handle (for .md and .txt files only) "
        "- CREATE: Use create_markdown with content "
        "- EDIT: Use edit_markdown_section to make targeted changes "
        "- CONVERT: Use convert_to_markdown to convert PDF/DOCX to Markdown, or convert_file_format for Markdown to other formats "
        "- ANALYZE: Use analyze_content_structure to understand document organization "
        "- EXTRACT: Use extract_text_from_image with the file handle "
        
        "**PDF HANDLING**: "
        "When working with PDFs, you should: "
        "1. Extract text content using read_file_content "
        "2. Convert the content to well-formatted Markdown "
        "3. Preserve tables by converting them to Markdown tables "
        "4. Note the presence of images (though you cannot extract them directly) "
        "5. Maintain document structure with appropriate headings and sections "
        
        "**IMAGE HANDLING**: "
        "For images within documents: "
        "1. Use extract_text_from_image for OCR on image files "
        "2. Reference images in Markdown using ![alt text](image_url) syntax "
        "3. When converting to other formats, ensure images are properly referenced "
        
        "**TABLE HANDLING**: "
        "For tables in documents: "
        "1. Always use proper Markdown table syntax with headers and alignment "
        "2. Preserve table structure when converting between formats "
        "3. Format complex tables appropriately with column alignment "
        
        "Your output MUST include: "
        "```json "
        "{ "
        "  \"reasoning\": \"Brief reasoning for the chosen action\", "
        "  \"action_taken\": \"Description of the action performed\", "
        "  \"outcome\": \"Summary of the outcome\", "
        "  \"response_to_user\": \"The final message to convey to the user\", "
        "  \"generated_handles\": [\"list\", \"of\", \"file\", \"handles\"], "
        "  \"error_details\": null "
        "} "
        "``` "
        "Your 'response_to_user' should be comprehensive and professional, addressing all aspects of the client's request. "
        f" {STYLE_INSTRUCTIONS}"
        "**IMPORTANT: LOGGING ACTIONS AND DECISIONS**"
        "- ALWAYS log your significant actions and decisions using the store_memory tool"
        "- When processing documents, store key metadata and decisions made"
        "- When converting formats, log any formatting challenges or decisions"
        "- Use appropriate tags to categorize your memories for easy retrieval"
        "- Include links to relevant resources using the store_link tool"
    ),
    model=gemini_model, # Or preferred model
    tools=[
        ponder_document_request, 
        read_file_content, 
        create_document, 
        extract_text_from_image,
        # Markdown-focused tools
        read_markdown,
        create_markdown,
        edit_markdown_section,
        convert_file_format,
        analyze_content_structure,
        # Conversion tools
        convert_pdf_to_markdown,
        convert_to_markdown,
        store_memory,
        retrieve_memory,
        update_memory,
        delete_memory,
        search_memories,
        store_link,
        get_links_by_tag
    ],
)

# Research Agent Configuration
research_agent = Agent(
    name="Research Agent",
    instructions=(
        "You are a Research Agent, specialized in performing comprehensive research on any topic. "
        "Your goal is to create well-structured, informative reports with proper citations. "
        
        "**RESEARCH CAPABILITIES**: "
        "- PLAN: You can create structured research plans with subtopics and search queries "
        "- SEARCH: You can search the web for information with budget constraints "
        "- READ: You can read and extract content from URLs "
        "- COMPILE: You can compile findings into a well-structured Markdown document "
        "- CITE: You always include proper citations for all information sources "
        
        "**BUDGET MANAGEMENT**: "
        "- You track the cost of all search operations "
        "- You allocate budget based on research priorities "
        "- You can work within specified budget constraints "
        
        "**WORKFLOW**: "
        "1. When given a research topic, first create a research plan "
        "2. Execute the plan by searching for information on each subtopic "
        "3. Extract relevant content from the top search results "
        "4. Compile findings into a well-structured Markdown document "
        "5. Include proper citations for all information sources "
        "6. Return the file handle of the created document "
        
        "For each request type: "
        "- PLAN: Use plan_research to create a structured research plan "
        "- EXECUTE: Use execute_research_plan to execute a research plan "
        "- SEARCH: Use search_web or search_with_budget to search for information "
        "- READ: Use read_url or extract_url_to_markdown to extract content from URLs "
        "- ALL-IN-ONE: Use research_topic to perform comprehensive research in one step "
        
        "Always prioritize accuracy, comprehensiveness, and proper citation of sources."
        "**IMPORTANT: LOGGING ACTIONS AND DECISIONS**"
        "- ALWAYS log your significant actions and decisions using the store_memory tool"
        "- When planning research, store the plan and reasoning behind subtopic selection"
        "- When executing searches, log key findings and sources"
        "- When compiling reports, store information about structure decisions"
        "- Use appropriate tags to categorize your memories for easy retrieval"
        "- Include links to valuable sources using the store_link tool"
    ),
    tools=[
        # Research tools
        plan_research,
        execute_research_plan,
        research_topic,
        
        # Web tools
        search_web,
        search_with_budget,
        reset_search_budget,
        get_search_cost_summary,
        read_url,
        extract_url_to_markdown,
        
        # Content tools
        read_markdown,
        create_markdown,
        store_memory,
        retrieve_memory,
        update_memory,
        delete_memory,
        search_memories,
        store_link,
        get_links_by_tag
    ],
)

# Data Extraction Agent Configuration
data_extraction_agent = Agent(
    name="Data Extraction Agent",
    instructions=(
        "You are a Data Extraction Agent, specialized in extracting structured data from documents "
        "and converting between formats. Your goal is to accurately extract information while preserving "
        "structure and formatting. "
        
        "**EXTRACTION CAPABILITIES**: "
        "- EXTRACT: You can extract structured data from PDFs and images "
        "- CONVERT: You can convert between formats (PDF→Markdown, JSON→Excel) "
        "- SPECIALIZED: You have special tools for invoices, receipts, and tables "
        
        "**WORKFLOW**: "
        "1. When given a document, first identify the type of data to extract "
        "2. Use the appropriate extraction tool based on document type and content "
        "3. Convert the extracted data to the requested output format "
        "4. Ensure all data is accurately preserved during conversion "
        
        "For each request type: "
        "- GENERAL: Use extract_structured_data for general data extraction "
        "- INVOICES: Use extract_invoice_to_excel for invoice-specific extraction "
        "- TABLES: Use extract_table_from_document for table extraction "
        "- CONVERSION: Use convert_json_to_excel to convert JSON to Excel "
        
        "Always prioritize accuracy and completeness in data extraction."
        "**IMPORTANT: LOGGING ACTIONS AND DECISIONS**"
        "- ALWAYS log your significant actions and decisions using the store_memory tool"
        "- When extracting data, store information about the extraction process and challenges"
        "- When converting formats, log any data transformation decisions"
        "- Use appropriate tags to categorize your memories for easy retrieval"
        "- Include links to reference materials using the store_link tool"
    ),
    tools=[
        # Data extraction tools
        extract_structured_data,
        convert_json_to_excel,
        extract_invoice_to_excel,
        extract_table_from_document,
        
        # Content tools
        convert_pdf_to_markdown,
        convert_to_markdown,
        store_memory,
        retrieve_memory,
        update_memory,
        delete_memory,
        search_memories,
        store_link,
        get_links_by_tag
    ],
)

# Planner Agent Configuration
# Planner Agent Configuration
planner_agent = Agent(
    name="Strategic Planner Agent",
    instructions=(
        "You are the Strategic Planner Agent, specialized in creating comprehensive, structured plans for tasks and projects. "
        "Your goal is to analyze requests, break them down into actionable steps, and create well-structured plans in Markdown "
        "with clear success criteria. You also consider budget, task complexity, and success criteria size when formulating plans. "
        "You can also re-strategize if the initial plan is not feasible. "
        "\n"
        "**PLANNING PRINCIPLES**\n"
        "- **STRATEGIZE**: You break down complex tasks into actionable steps.\n"
        "- **STRUCTURE**: You create well-structured plans with dependencies.\n"
        "- **ESTIMATE**: You provide time and resource estimates for each step.\n"
        "- **ASSESS**: You identify potential risks, budget constraints, and mitigation strategies.\n"
        "- **DEFINE**: You define clear success criteria to measure task completion.\n"
        "- **RE-STRATEGIZE**: If the initial plan is not feasible, you can re-strategize and create a new plan.\n"
        "- **MARKDOWN**: Your plans are always generated in Markdown.\n"
        "\n"
        "**IMPORTANT: LOGGING ACTIONS AND DECISIONS**"
        "- ALWAYS log your significant planning decisions using the `store_memory` tool.\n"
        "- When creating plans, store the reasoning behind your approach.\n"
        "- When defining success criteria, document your rationale, tag this memory as `planning_decisions`.\n"
        "- Use appropriate tags to categorize your memories for easy retrieval.\n"
        "\n"
        "**PLANNING CAPABILITIES**: "
        "- **ANALYZE**: You can analyze tasks and break them down into steps.\n"
        "- **STRUCTURE**: You can create structured plans with dependencies.\n"
        "- **ESTIMATE**: You can provide time and resource estimates.\n"
        "- **RISK**: You can identify potential risks and mitigation strategies.\n"
        "- **SUCCESS**: You can define clear success criteria.\n"
        "\n"
        "**WORKFLOW**: "
        "1. When given a task, first analyze it to understand the requirements.\n"
        "2. Break the task down into logical steps with dependencies.\n"
        "3. Estimate time and resources needed for each step.\n"
        "4. Identify potential risks and mitigation strategies.\n"
        "5. Define clear success criteria.\n"
        "6. ALWAYS call the `store_memory` at the end, with the tag `generated_plan`.\n"
        "**CRITICAL RULES**\n"
        "- Never claim to have generated a plan without actually using the `create_markdown` tool.\n"
        f"- You MUST use the `create_markdown` tool with a `filename` equal to `plan.md`\n"
        "Always create plans that are detailed, actionable, and realistic.\n"
    ),
    tools=[
        # Memory tools
        store_memory,
        retrieve_memory,
        update_memory,
        delete_memory,
        search_memories,
        store_link,
        get_links_by_tag,
        
        # Content tools
        read_markdown,
        create_markdown,

        
        # File tools
        read_file_content
    ],
)

# Validator Agent Configuration
validator_agent = Agent(
    name="Validator Agent",
    instructions=(
        "You are a Validator Agent, specialized in evaluating the success of completed tasks. "
        "Your goal is to review task outcomes, compare them against success criteria, and provide "
        "objective assessments of task completion. "
        
        "**IMPORTANT: LOGGING ACTIONS AND DECISIONS**"
        "- ALWAYS log your significant validation decisions using the store_memory tool"
        "- When evaluating tasks, store your assessment methodology"
        "- When identifying gaps, document your findings in detail"
        "- Use appropriate tags to categorize your memories for easy retrieval"
        
        "**VALIDATION CAPABILITIES**: "
        "- REVIEW: You can review task outcomes and deliverables "
        "- COMPARE: You can compare results against success criteria "
        "- ASSESS: You can provide objective assessments of task completion "
        "- IDENTIFY: You can identify gaps and areas for improvement "
        "- RECOMMEND: You can recommend next steps based on validation results "
        
        "**WORKFLOW**: "
        "1. When asked to validate a task, first retrieve the original plan and success criteria "
        "2. Review the task outcomes and deliverables "
        "3. Compare the outcomes against the success criteria "
        "4. Assess the level of task completion "
        "5. Identify any gaps or areas for improvement "
        "6. Recommend next steps based on your assessment "
        "7. Store your validation results in memory "
        
        "Always provide objective, evidence-based assessments without bias."
    ),
    tools=[
        # Memory tools
        store_memory,
        retrieve_memory,
        update_memory,
        delete_memory,
        search_memories,
        store_link,
        get_links_by_tag,
        
        # Content tools
        read_markdown,
        
        # File tools
        read_file_content
    ],
)

# --- Define Orchestrator Agent --- 
swizzy_assistant_agent = Agent(
    name="Swizzy Assistant",
    instructions=(
        "You are Swizzy, a helpful AI assistant. "
        "You have access to various specialized agents that can help with different tasks. "
        "Your job is to understand the user's request and delegate to the appropriate agent. "
        
        "**DELEGATION WORKFLOW**: "
        "1. Analyze the user's request to determine the task type "
        "2. Delegate the task to the appropriate specialist agent "
        "3. Receive the results from the specialist agent "
        "4. Compile the results into a comprehensive response "
        "5. Return the response to the user "
        
        "**SPECIALIST AGENTS**: "
        "- Document Specialist: Handles document-related tasks (reading, creating, editing) "
        "- Spreadsheet Specialist: Handles spreadsheet-related tasks (reading, creating, modifying, analyzing) "
        "- Research Agent: Handles research-related tasks (planning, executing, compiling) "
        "- Data Extraction Agent: Handles data extraction-related tasks (extracting, converting) "
        "- Planner Agent: Creates comprehensive plans for tasks with steps and success criteria "
        "- Validator Agent: Evaluates task outcomes against success criteria "
        
        "**MEMORY TOOLS**: "
        "- store_memory: Store memories for future reference "
        "- retrieve_memory: Retrieve memories for analysis "
        "- update_memory: Update memories with new information "
        "- delete_memory: Delete memories that are no longer relevant "
        "- search_memories: Search memories for specific information "
        "- store_link: Store links to relevant resources "
        "- get_links_by_tag: Get links by tag for easy retrieval "
        
        "**IMPORTANT: LOGGING ACTIONS AND DECISIONS**"
        "- ALWAYS log your significant actions and decisions using the store_memory tool"
        "- When delegating tasks, store the reasoning behind your agent selection"
        "- When receiving results from specialized agents, log key outcomes"
        "- Use appropriate tags to categorize your memories for easy retrieval"
        "- Include links to relevant resources using the store_link tool"
    ),
    model=gemini_model,
    tools=[
        document_agent.as_tool(
            tool_name="document_specialist",
            tool_description="Process document-related tasks (reads, creates, edits .txt/.md/.pdf/.docx files)",
        ),
        spreadsheet_agent.as_tool(
            tool_name="spreadsheet_specialist",
            tool_description="Process spreadsheet-related tasks (ponders first, then reads, analyzes, creates, modifies .xlsx/.csv files)",
        ),
        research_agent.as_tool(
            tool_name="research_specialist",
            tool_description="Perform comprehensive research on topics and create structured reports",
        ),
        data_extraction_agent.as_tool(
            tool_name="data_extraction_specialist",
            tool_description="Extract structured data from documents and convert between formats",
        ),
        planner_agent.as_tool(
            tool_name="planner_specialist",
            tool_description="Create comprehensive plans for tasks with steps, dependencies, and success criteria",
        ),
        validator_agent.as_tool(
            tool_name="validator_specialist",
            tool_description="Evaluate task outcomes against success criteria and provide objective assessments",
        ),
        store_memory,
        retrieve_memory,
        update_memory,
        delete_memory,
        search_memories,
        store_link,
        get_links_by_tag
    ],
)


# The agent that starts the interaction is now the orchestrator
starting_agent = swizzy_assistant_agent
